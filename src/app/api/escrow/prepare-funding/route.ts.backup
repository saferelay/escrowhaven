import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';
import { getConfig } from '@/lib/config';
import { ethers } from 'ethers';

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
);

const SAFERELAY_FACTORY_ABI = [
  "function createEscrow(string memory payerEmail, string memory recipientEmail, address recipientWallet, uint256 amount) returns (address escrow, address splitter)",
  "event EscrowCreated(address indexed escrow, address indexed splitter, string payerEmail, string recipientEmail, address recipientWallet, uint256 amount)"
];

export async function POST(request: NextRequest) {
  console.log('=== PREPARE FUNDING API CALLED ===');
  
  try {
    const body = await request.json();
    console.log('Request body:', body);
    
    const { escrowId, useTransakOne = false } = body;
    
    if (!escrowId) {
      return NextResponse.json(
        { error: 'Missing escrowId' },
        { status: 400 }
      );
    }
    
    // Get escrow from database
    const { data: pendingEscrow, error: dbError } = await supabase
      .from('pending_escrows')
      .select('*')
      .eq('id', escrowId)
      .single();
    
    if (dbError || !pendingEscrow) {
      console.error('Database error:', dbError);
      return NextResponse.json(
        { error: 'Escrow not found' },
        { status: 404 }
      );
    }
    
    console.log('Found escrow:', {
      id: pendingEscrow.id,
      status: pendingEscrow.status,
      vault: pendingEscrow.vault_address
    });
    
    // Validation
    if (pendingEscrow.status !== 'ACCEPTED') {
      return NextResponse.json(
        { error: 'Escrow must be accepted first. Current status: ' + pendingEscrow.status },
        { status: 400 }
      );
    }
    
    if (!pendingEscrow.recipient_wallet_address) {
      return NextResponse.json(
        { error: 'Recipient wallet not set' },
        { status: 400 }
      );
    }
    
    const amountUsd = pendingEscrow.amount_cents / 100;
    
    // If vault already deployed, return it
    if (pendingEscrow.vault_address) {
      console.log('Vault already deployed at:', pendingEscrow.vault_address);
      return NextResponse.json({ 
        transakParams: {
          walletAddress: pendingEscrow.vault_address,
          amountUsd: amountUsd,
          escrowId: escrowId,
          productsAvailed: 'BUY'
        },
        escrowId,
        amountUsd,
        vaultAddress: pendingEscrow.vault_address
      });
    }
    
    // Deploy vault
    console.log('Deploying vault...');
    
    const privateKey = process.env.PRIVATE_KEY;
    const factoryAddress = process.env.SAFERELAY_FACTORY_ADDRESS;
    
    if (!privateKey) {
      return NextResponse.json(
        { error: 'Server configuration error: Missing private key' },
        { status: 500 }
      );
    }
    
    if (!factoryAddress) {
      return NextResponse.json(
        { error: 'Server configuration error: Missing factory address' },
        { status: 500 }
      );
    }
    
    try {
      // Try multiple RPC endpoints
      const rpcUrls = [
        'https://rpc-amoy.polygon.technology',
        'https://polygon-amoy-bor-rpc.publicnode.com'
      ];
      
      let provider: ethers.providers.JsonRpcProvider | null = null;
      let lastError: any = null;
      
      // Try each RPC until one works
      for (const rpcUrl of rpcUrls) {
        try {
          console.log('Trying RPC:', rpcUrl);
          const testProvider = new ethers.providers.JsonRpcProvider(rpcUrl);
          
          // Test the connection with a timeout
          const timeoutPromise = new Promise((_, reject) => 
            setTimeout(() => reject(new Error('Connection timeout')), 5000)
          );
          
          const networkPromise = testProvider.getNetwork();
          await Promise.race([networkPromise, timeoutPromise]);
          
          provider = testProvider;
          console.log('✅ Connected to:', rpcUrl);
          break;
        } catch (error: any) {
          console.log('❌ Failed:', error.message);
          lastError = error;
          continue;
        }
      }
      }
      
      if (!provider) {
        throw new Error('All RPC endpoints failed: ' + lastError?.message);
      }
      
      const signer = new ethers.Wallet(privateKey, provider);
      console.log('Signer address:', signer.address);
      
      // Check balance
      const balance = await provider.getBalance(signer.address);
      console.log('Signer balance:', ethers.utils.formatEther(balance), 'MATIC');
      
      if (balance.isZero()) {
        return NextResponse.json(
          { error: 'Insufficient MATIC for gas fees' },
          { status: 500 }
        );
      }
      
      // Deploy escrow
      const factory = new ethers.Contract(factoryAddress, SAFERELAY_FACTORY_ABI, signer);
      const amountUsdc = ethers.utils.parseUnits(amountUsd.toString(), 6);
      
      console.log('Calling createEscrow with:', {
        payerEmail: pendingEscrow.client_email,
        recipientEmail: pendingEscrow.freelancer_email,
        recipientWallet: pendingEscrow.recipient_wallet_address,
        amount: amountUsdc.toString()
      });
      
      const tx = await factory.createEscrow(
        pendingEscrow.client_email,
        pendingEscrow.freelancer_email,
        pendingEscrow.recipient_wallet_address,
        amountUsdc,
        { gasLimit: 500000 }
      );
      
      console.log('Transaction sent:', tx.hash);
      
      const receipt = await tx.wait();
      console.log('Transaction confirmed');
      
      // Find event
      const event = receipt.events?.find((e: any) => e.event === 'EscrowCreated');
      if (!event) {
        console.error('No EscrowCreated event found');
        return NextResponse.json(
          { error: 'Deployment succeeded but no event found' },
          { status: 500 }
        );
      }
      
      const vaultAddress = event.args.escrow;
      const splitterAddress = event.args.splitter;
      
      console.log('Vault deployed:', vaultAddress);

      // Update pending_escrows with vault information
      const { error: updatePendingError } = await supabase
        .from('pending_escrows')
        .update({
          vault_address: vaultAddress,
          splitter_address: splitterAddress,
          deployment_tx: tx.hash,
          deployment_status: 'DEPLOYED'
        })
        .eq('id', escrowId);
      
      if (updatePendingError) {
        console.error('Failed to update pending_escrows with vault info:', updatePendingError);
      } else {
        console.log('Updated pending_escrows with vault address');
      }
      
      // Return success
      return NextResponse.json({ 
        transakParams: {
          walletAddress: vaultAddress,
          amountUsd: amountUsd,
          escrowId: escrowId,
          productsAvailed: 'BUY'
        },
        escrowId,
        amountUsd,
        vaultAddress
      });} catch (deployError: any) {
      console.error('Deployment error:', deployError);
      console.error('Error details:', {
        message: deployError.message,
        code: deployError.code,
        reason: deployError.reason
      });
      
      return NextResponse.json(
        { error: `Deployment failed: ${deployError.message || 'Unknown error'}` },
        { status: 500 }
      );
    }
    
  } catch (error: any) {
    console.error('Prepare funding error:', error);
    return NextResponse.json(
      { error: error.message || 'Internal server error' },
      { status: 500 }
    );
  }
}
