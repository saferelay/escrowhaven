// src/app/api/escrow/create-transparent/route.ts
// Working version that bypasses Next.js fetch issues

import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';
import { ethers } from 'ethers';
const { providers, utils, Wallet, Contract } = ethers;

// Handle CORS
export async function OPTIONS(request: NextRequest) {
  return new NextResponse(null, {
    status: 200,
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'POST, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type',
    },
  });
}

export async function POST(request: NextRequest) {
  console.log('=== Create Escrow API Called ===');
  
  const corsHeaders = {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Methods': 'POST, OPTIONS',
    'Access-Control-Allow-Headers': 'Content-Type',
  };
  
  try {
    // Initialize Supabase
    const supabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
    );

    // Parse request
    const body = await request.json();
    console.log('Request:', body);
    const { amountUsd, clientEmail, freelancerEmail } = body;

    // Validation
    if (!amountUsd || !clientEmail || !freelancerEmail) {
      return NextResponse.json(
        { error: 'Missing required fields' },
        { status: 400, headers: corsHeaders }
      );
    }

    if (amountUsd < 1 || amountUsd > 50000) {
      return NextResponse.json(
        { error: 'Amount must be between $1 and $50,000' },
        { status: 400, headers: corsHeaders }
      );
    }

    // Generate salt and addresses
    const timestamp = Date.now();
    const saltString = `${clientEmail}-${freelancerEmail}-${timestamp}`;
    const salt = utils.keccak256(utils.toUtf8Bytes(saltString));
    
    const clientAddress = utils.getAddress(
      '0x' + utils.keccak256(utils.toUtf8Bytes(clientEmail)).slice(26)
    );
    const freelancerAddress = utils.getAddress(
      '0x' + utils.keccak256(utils.toUtf8Bytes(freelancerEmail)).slice(26)
    );

    console.log('Generated addresses:', { clientAddress, freelancerAddress });

    // Configuration
    const config = {
      ALCHEMY_API_KEY: process.env.ALCHEMY_API_KEY,
      PRIVATE_KEY: process.env.PRIVATE_KEY!,
      FACTORY_ADDRESS: process.env.POLYGON_FACTORY_ADDRESS || '0xd06C2D9CCfef0798d3A9273BfBe61467FE8611eC',
      WALLET_ADDRESS: '0xE99318b378CC5C163223bbfF06D4d5159E4e5f1e'
    };

    let vaultAddress: string;
    let txHash: string;
    let network: string;
    let message: string;
    let mode: 'blockchain' | 'demo' = 'demo';

    // Try blockchain if we have all requirements
    if (config.ALCHEMY_API_KEY && config.PRIVATE_KEY) {
      try {
        console.log('üîó Attempting blockchain vault address generation...');
        
        // For Next.js compatibility, we'll just calculate the vault address
        // without making RPC calls. The actual deployment will happen separately.
        
        // Calculate deterministic vault address
        const factoryAddress = config.FACTORY_ADDRESS;
        const initCodeHash = '0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f'; // Placeholder
        
        // Simplified vault address calculation
        vaultAddress = utils.getAddress(
          '0x' + utils.keccak256(
            utils.concat([
              '0xff',
              factoryAddress,
              salt,
              initCodeHash
            ])
          ).slice(26)
        );
        
        // For now, mark as pending blockchain deployment
        txHash = '0xpending_' + Date.now().toString(16);
        network = 'polygon-amoy';
        message = '‚úÖ Escrow created (pending blockchain deployment)';
        mode = 'blockchain';
        
        console.log('Vault address calculated:', vaultAddress);
        
      } catch (error: any) {
        console.error('‚ùå Blockchain calculation error:', error.message);
        // Fall through to demo mode
      }
    }

    // Fallback to demo mode if blockchain failed or not configured
    if (mode === 'demo') {
      console.log('üìù Using demo mode');
      vaultAddress = utils.getAddress(
        '0x' + utils.keccak256(
          utils.concat(['0x' + salt.slice(2), clientAddress, freelancerAddress])
        ).slice(26)
      );
      txHash = '0xdemo_' + utils.keccak256(utils.toUtf8Bytes(`${salt}-${timestamp}`)).slice(2);
      network = 'polygon-amoy-demo';
      message = '‚úÖ Escrow created in demo mode';
    }

    console.log('Vault address:', vaultAddress);

    // Save to database
    const { data, error } = await supabase
      .from('escrows')
      .insert({
        amount_cents: Math.round(amountUsd * 100),
        vault_address: vaultAddress,
        status: 'PENDING',
        client_email: clientEmail,
        freelancer_email: freelancerEmail,
        client_approved: false,
        freelancer_approved: false,
        platform_fee_cents: Math.round(amountUsd * 100 * 0.0199),
        freelancer_amount_cents: Math.round(amountUsd * 100 * 0.9801),
        network: network,
        tx_hash: txHash,
        salt: salt
      })
      .select()
      .single();

    if (error) {
      console.error('Database error:', error);
      throw new Error('Failed to save escrow: ' + error.message);
    }

    console.log('‚úÖ Escrow saved to database:', data.id);

    // Return response
    const response = {
      escrowId: data.id,
      escrowAddress: vaultAddress,
      status: 'PENDING',
      amountUsd: amountUsd,
      network: network,
      transactionHash: txHash,
      explorerUrl: network === 'polygon-amoy' 
        ? `https://amoy.polygonscan.com/address/${vaultAddress}`
        : `https://www.oklink.com/amoy/address/${vaultAddress}`,
      message: message,
      mode: mode,
      note: mode === 'blockchain' 
        ? 'Vault address generated. Run deployment script to deploy on-chain.'
        : 'Demo mode - no blockchain interaction'
    };

    console.log('=== Escrow Creation Complete ===\n');
    return NextResponse.json(response, { headers: corsHeaders });

  } catch (error: any) {
    console.error('Unexpected error:', error);
    return NextResponse.json(
      { 
        error: 'Internal server error',
        message: error.message || 'Unknown error occurred',
        timestamp: new Date().toISOString()
      },
      { status: 500, headers: corsHeaders }
    );
  }
}
