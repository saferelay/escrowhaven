// src/app/api/escrow/create-transparent/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';
import { ethers } from 'ethers';
const { providers, utils, Wallet, Contract } = ethers;

// Fix for Next.js fetch issues with ethers
if (!global.fetch) {
  global.fetch = fetch;
}

// Initialize Supabase
const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
);

// Configuration
const CONFIG = {
  ALCHEMY_API_KEY: process.env.ALCHEMY_API_KEY,
  PRIVATE_KEY: process.env.PRIVATE_KEY,
  FACTORY_ADDRESS: process.env.POLYGON_FACTORY_ADDRESS || '0xd06C2D9CCfef0798d3A9273BfBe61467FE8611eC',
  FORCE_DEMO_MODE: process.env.FORCE_DEMO_MODE === 'true',
};

// Factory ABI
const FACTORY_ABI = [
  "function createEscrow(bytes32 salt, address client, address freelancer, uint256 amount) returns (address)",
  "event EscrowCreated(address indexed escrowAddress, bytes32 indexed salt, address indexed client, address freelancer, uint256 amount)"
];

// CORS headers
const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Methods': 'POST, OPTIONS',
  'Access-Control-Allow-Headers': 'Content-Type',
};

// Handle preflight requests
export async function OPTIONS(request: NextRequest) {
  return new NextResponse(null, {
    status: 200,
    headers: corsHeaders,
  });
}

export async function POST(request: NextRequest) {
  console.log('=== Create Escrow API Called ===');
  
  try {
    // Parse and validate request
    const body = await request.json();
    const { amountUsd, clientEmail, freelancerEmail } = body;
    
    console.log('Request:', { amountUsd, clientEmail, freelancerEmail });

    // Validation
    if (!amountUsd || !clientEmail || !freelancerEmail) {
      return NextResponse.json(
        { error: 'Missing required fields' },
        { status: 400, headers: corsHeaders }
      );
    }

    if (amountUsd < 0.01 || amountUsd > 50000) {
      return NextResponse.json(
        { error: 'Amount must be between $0.01 and $50,000' },
        { status: 400, headers: corsHeaders }
      );
    }

    // Generate deterministic values
    const timestamp = Date.now();
    const saltString = `${clientEmail}-${freelancerEmail}-${timestamp}`;
    const salt = utils.keccak256(utils.toUtf8Bytes(saltString));
    
    // Generate addresses from emails (for demo purposes)
    const clientAddress = utils.getAddress('0x' + utils.keccak256(utils.toUtf8Bytes(clientEmail)).slice(26));
    const freelancerAddress = utils.getAddress('0x' + utils.keccak256(utils.toUtf8Bytes(freelancerEmail)).slice(26));

    console.log('Generated addresses:', { clientAddress, freelancerAddress });

    // Determine mode and create escrow
    let escrowResult;
    
    if (CONFIG.FORCE_DEMO_MODE) {
      console.log('📝 Running in FORCED DEMO MODE');
      escrowResult = await createDemoEscrow(salt, clientAddress, freelancerAddress, amountUsd);
    } else if (!CONFIG.ALCHEMY_API_KEY || !CONFIG.PRIVATE_KEY) {
      console.log('⚠️  Missing blockchain credentials, using DEMO MODE');
      console.log('   - Alchemy Key:', CONFIG.ALCHEMY_API_KEY ? '✅' : '❌');
      console.log('   - Private Key:', CONFIG.PRIVATE_KEY ? '✅' : '❌');
      escrowResult = await createDemoEscrow(salt, clientAddress, freelancerAddress, amountUsd);
    } else {
      console.log('🔗 Attempting BLOCKCHAIN transaction...');
      try {
        escrowResult = await createBlockchainEscrow(
          salt, 
          clientAddress, 
          freelancerAddress, 
          amountUsd,
          CONFIG
        );
        console.log('✅ Blockchain escrow created successfully!');
      } catch (blockchainError: any) {
        console.error('❌ Blockchain error:', blockchainError.message);
        console.log('↩️  Falling back to DEMO MODE');
        escrowResult = await createDemoEscrow(salt, clientAddress, freelancerAddress, amountUsd);
        escrowResult.blockchainError = blockchainError.message;
      }
    }

    // Save to database
    const { data, error } = await supabase
      .from('escrows')
      .insert({
        amount_cents: Math.round(amountUsd * 100),
        vault_address: escrowResult.vaultAddress,
        status: 'PENDING',
        client_email: clientEmail,
        freelancer_email: freelancerEmail,
        client_approved: false,
        freelancer_approved: false,
        platform_fee_cents: Math.round(amountUsd * 100 * 0.0199),
        freelancer_amount_cents: Math.round(amountUsd * 100 * 0.9801),
        network: escrowResult.network,
        tx_hash: escrowResult.txHash,
        salt: salt
      })
      .select()
      .single();

    if (error) {
      console.error('Database error:', error);
      throw new Error('Failed to save escrow: ' + error.message);
    }

    console.log('✅ Escrow saved to database:', data.id);

    // Prepare response
    const response = {
      escrowId: data.id,
      escrowAddress: escrowResult.vaultAddress,
      status: 'PENDING',
      amountUsd: amountUsd,
      network: escrowResult.network,
      transactionHash: escrowResult.txHash,
      explorerUrl: escrowResult.network === 'polygon-amoy' 
        ? `https://www.oklink.com/amoy/tx/${escrowResult.txHash}`
        : `https://www.oklink.com/amoy/address/${escrowResult.vaultAddress}`,
      message: escrowResult.network === 'polygon-amoy'
        ? '✅ Blockchain escrow created successfully!'
        : '✅ Escrow created in demo mode',
      mode: escrowResult.network === 'polygon-amoy' ? 'blockchain' : 'demo',
      ...(escrowResult.blockchainError && { 
        note: `Demo mode due to: ${escrowResult.blockchainError}` 
      })
    };

    console.log('=== Escrow Creation Complete ===\n');
    return NextResponse.json(response, { headers: corsHeaders });

  } catch (error: any) {
    console.error('Unexpected error:', error);
    return NextResponse.json(
      { 
        error: 'Internal server error',
        message: error.message || 'Unknown error occurred',
        timestamp: new Date().toISOString()
      },
      { status: 500, headers: corsHeaders }
    );
  }
}

// Create escrow on blockchain
async function createBlockchainEscrow(
  salt: string,
  clientAddress: string,
  freelancerAddress: string,
  amountUsd: number,
  config: typeof CONFIG
) {
  // Initialize provider with Alchemy
  // Use StaticJsonRpcProvider to bypass network detection issues
  const provider = new providers.StaticJsonRpcProvider(
    {
      url: `https://polygon-amoy.g.alchemy.com/v2/${config.ALCHEMY_API_KEY}`,
      timeout: 30000,
      headers: {
        'Content-Type': 'application/json'
      }
    },
    {
      chainId: 80002,
      name: 'polygon-amoy'
    }
  );
  
  // Test connection
  // Using static network config
  const network = { chainId: 80002, name: 'polygon-amoy' };
  console.log('Connected to network:', network.name || 'polygon-amoy', 'chainId:', network.chainId);
  
  // Verify we're on Polygon Amoy (chainId 80002)
  if (network.chainId !== 80002) {
    throw new Error(`Wrong network! Expected Polygon Amoy (80002), got ${network.chainId}`);
  }
  
  // Initialize wallet
  const wallet = new Wallet(config.PRIVATE_KEY!, provider);
  console.log('Wallet address:', wallet.address);
  
  // Check wallet balance
  const balance = await provider.getBalance(wallet.address);
  console.log('Wallet balance:', utils.formatEther(balance), 'MATIC');
  
  if (balance.eq(0)) {
    throw new Error('Wallet has no MATIC for gas fees');
  }
  
  // Initialize factory contract
  const factory = new Contract(config.FACTORY_ADDRESS, FACTORY_ABI, wallet);
  
  // Convert USD to USDC units (6 decimals)
  const amountUsdc = utils.parseUnits(amountUsd.toString(), 6);
  
  // Send transaction
  console.log('Sending transaction...');
  const tx = await factory.createEscrow(salt, clientAddress, freelancerAddress, amountUsdc, {
    gasLimit: 500000 // Set reasonable gas limit
  });
  
  console.log('Transaction sent:', tx.hash);
  console.log('Waiting for confirmation...');
  
  // Wait for confirmation
  const receipt = await tx.wait();
  console.log('Transaction confirmed in block:', receipt.blockNumber);
  
  // Extract vault address from event
  const event = receipt.events?.find((e: any) => e.event === 'EscrowCreated');
  if (!event || !event.args) {
    throw new Error('Failed to parse escrow creation event');
  }
  
  const vaultAddress = event.args[0];
  console.log('Vault address:', vaultAddress);
  
  return {
    vaultAddress,
    txHash: tx.hash,
    network: 'polygon-amoy'
  };
}

// Create demo escrow (no blockchain)
async function createDemoEscrow(
  salt: string,
  clientAddress: string,
  freelancerAddress: string,
  amountUsd: number
) {
  // Generate deterministic mock vault address
  const vaultAddress = utils.getAddress(
    '0x' + utils.keccak256(
      utils.concat([
        salt,
        clientAddress,
        freelancerAddress
      ])
    ).slice(26)
  );
  
  // Generate mock transaction hash
  const mockTxHash = '0x' + utils.keccak256(
    utils.toUtf8Bytes(`demo-${salt}-${Date.now()}`)
  ).slice(2);
  
  console.log('Demo vault address:', vaultAddress);
  
  return {
    vaultAddress,
    txHash: mockTxHash,
    network: 'polygon-amoy-demo'
  };
}